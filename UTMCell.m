//
// inSTREAM-SD-2D (inSTREAM version 3.1)
// Developed by Lang Railsback & Assoc., Arcata CA for Argonne National Laboratory
// Software maintained by Jackson Scientific Computing, McKinleyville CA;
// This library is distributed without any warranty; without even the
// implied warranty of merchantability or fitness for a particular purpose.
// See file LICENSE for details and terms of copying
// 


/*
UTMCell is designed as a generic 3- or 4-sided cell created from UTM coordinates. 
It uses these data types and variables:

(NOTE: In inSTREAM, variables labeled "UTM", "Northing", and "Easting" are 
not really UTM coordinates; they are coordinates converted from meters to centimeters
--the conversion is made as soon as the coordinates are read in from file input.)

UTMPoint:    A structure variable type defined in UTMCell.h;
        contains (double) variables "x" and "y".

DisplayPoint:    A structure variable type defined in UTMCell.h;
        contains (int) variables "x" and "y".

PixelCoord:    A structure variable type defined in UTMCell.h;
        contains (unsigned) variables "pixelx" and "pixely".

cornerNode1, 2, 3, 4: Node numbers (int) for the cell's corner nodes.

cornerNodeArray: An array containing the cornerNode variables.

corner1UTMEasting, Northing: Variables containing the UTM coordinates 
(double) of the cell's corners.

utmPointArray: An array of "UTMPoint" variables containing the UTM coordinates 
of the cell's corners.

corner1DisplayX, Y: Variables containing the display coordinates (unsigned int) 
for the cell's corners. Display coordinates are calculated from "UTM" coordinates by 

(a) subtracting the minimum northing (easting) over all points in the space, 

(b) rounding to an integer 

(c) dividing by the appropriate (X or Y) raster resolution variable 

(d) rounding to an integer again. 

Hence, the maximum resolution (smallest distance between display pixels) 
is 1 whole UTM value, in this case 1 cm.

displayPointArray: An array of "DisplayPoint" variables containing the 
cell's corner display coordinates.

utmCellPixels: A one-dimensional array of "PixelCoord" variables containing 
all the display pixels within the cell. Pixels are the spatial units of 
the graphical display; each pixel represents a space with 
dimensions (in centimeters) equal to rasterResolutionX by rasterResolutionY.

midPointNode1, 2, 3, 4: Node numbers for the cell's midpoint nodes. 
These nodes are generated by the hydrodynamic model and occur at 
the midpoint of the cell's sides. Used in the HabitatSpace.

midPoint1UTMEasting, Northing: UTM coordinates (double) for midpoint nodes. 
Use in the HabitatSpace.
*/ 


#import "UTMCell.h"

@implementation UTMCell

+ create: aZone 
{
  UTMCell* utmCell = [super create: aZone];

  utmCell->cellZone = [Zone create: aZone];

  utmCell->tagCell = NO;
  utmCell->velocityInterpolator = nil;
  utmCell->depthInterpolator = nil;
  utmCell->rasterColorVariable = NULL;
  return utmCell;
}


/////////////////////////////////////
//
// getUTMCellZone
//
/////////////////////////////////////
- (id <Zone>) getUTMCellZone
{
    return cellZone;
}

////////////////////////////////////
//
// setCellNumber
//
///////////////////////////////////
- setUTMCellNumber: (int) aUTMCellNumber
{
    utmCellNumber = aUTMCellNumber;
    return self;
}


////////////////////////////////
//
// getUTMCellNumber
//
////////////////////////////////
- (int) getUTMCellNumber
{
     return utmCellNumber;
}


////////////////////////////////////////
//
// setNumberOfNodes
//
////////////////////////////////////////
- setNumberOfNodes: (int) aNumberOfNodes
{
    numberOfNodes = aNumberOfNodes;
    return self;
}


//////////////////////////////////////
//
// getNumberOfNodes
//
/////////////////////////////////////
- (int) getNumberOfNodes
{
   return numberOfNodes;
}


///////////////////////////////////
//
// getCornerNodeArray
//
///////////////////////////////////
- (int **) getCornerNodeArray
{
   return cornerNodeArray;

}
////////////////////////////////////////
//
// setCornerNodesWith
//
///////////////////////////////////////
- setCornerNodesWith: (int) aCornerNode1
         cornerNode2: (int) aCornerNode2
         cornerNode3: (int) aCornerNode3
         cornerNode4: (int) aCornerNode4
{
   cornerNode1 = aCornerNode1;
   cornerNode2 = aCornerNode2;
   cornerNode3 = aCornerNode3;
   cornerNode4 = aCornerNode4;

   return self;
}


////////////////////////
//
// getCornerNode1
//
////////////////////////
- (int) getCornerNode1
{
   return cornerNode1;
}

////////////////////////
//
// getCornerNode2
//
////////////////////////
- (int) getCornerNode2
{
   return cornerNode2;
}

////////////////////////
//
// getCornerNode3
//
////////////////////////
- (int) getCornerNode3
{
   return cornerNode3;
}

////////////////////////
//
// getCornerNode4
//
////////////////////////
- (int) getCornerNode4
{
   return cornerNode4;
}


////////////////////////////////////////
//
//
//
///////////////////////////////////////
- setMinUTMEasting: (double) aCoordinate
{
    minUTMEasting = aCoordinate;
    return self;
}


//////////////////////////////////////////
//
//
//
//////////////////////////////////////////
- setMaxUTMNorthing: (double) aCoordinate
{
    maxUTMNorthing = aCoordinate;
    return self;
}



///////////////////////////////////////
//
// setCorner1UTMEasting
//
///////////////////////////////////////
- setCorner1UTMEasting: (double) aCoordinate
{
   corner1UTMEasting = aCoordinate;
   return self;
}

//////////////////////////////////
//
// getCorner1UTMEasting
//
//////////////////////////////////
- (double) getCorner1UTMEasting
{
    return corner1UTMEasting;
}


///////////////////////////////////////
//
// setCorner1UTMNorthing
//
///////////////////////////////////////
- setCorner1UTMNorthing: (double) aCoordinate
{
   corner1UTMNorthing = aCoordinate;
   return self;
}


//////////////////////////////////
//
// getCorner1UTMNorthing
//
//////////////////////////////////
- (double) getCorner1UTMNorthing
{
    return corner1UTMNorthing;
}


///////////////////////////////////////
//
// setCorner2UTMEasting
//
///////////////////////////////////////
- setCorner2UTMEasting: (double) aCoordinate
{
   corner2UTMEasting = aCoordinate;
   return self;
}


//////////////////////////////////
//
// getCorner2UTMEasting
//
//////////////////////////////////
- (double) getCorner2UTMEasting
{
    return corner2UTMEasting;
}


///////////////////////////////////////
//
// setCorner2UTMNorthing
//
///////////////////////////////////////
- setCorner2UTMNorthing: (double) aCoordinate
{
   corner2UTMNorthing = aCoordinate;
   return self;
}


//////////////////////////////////
//
// getCorner2UTMNorthing
//
//////////////////////////////////
- (double) getCorner2UTMNorthing
{
    return corner2UTMNorthing;
}


///////////////////////////////////////
//
// setCorner3UTMEasting
//
///////////////////////////////////////
- setCorner3UTMEasting: (double) aCoordinate
{
   corner3UTMEasting = aCoordinate;
   return self;
}


//////////////////////////////////
//
// getCorner3UTMEasting
//
//////////////////////////////////
- (double) getCorner3UTMEasting
{
    return corner3UTMEasting;
}


///////////////////////////////////////
//
// setCorner3UTMNorthing
//
///////////////////////////////////////
- setCorner3UTMNorthing: (double) aCoordinate
{
   corner3UTMNorthing = aCoordinate;
   return self;
}


//////////////////////////////////
//
// getCorner3UTMNorthing
//
//////////////////////////////////
- (double) getCorner3UTMNorthing
{
    return corner3UTMNorthing;
}

///////////////////////////////////////
//
// setCorner4UTMEasting
//
///////////////////////////////////////
- setCorner4UTMEasting: (double) aCoordinate
{
   corner4UTMEasting = aCoordinate;
   return self;
}


//////////////////////////////////
//
// getCorner4UTMEasting
//
//////////////////////////////////
- (double) getCorner4UTMEasting
{
    return corner4UTMEasting;
}


///////////////////////////////////////
//
// setCorner4UTMNorthing
//
///////////////////////////////////////
- setCorner4UTMNorthing: (double) aCoordinate
{
   corner4UTMNorthing = aCoordinate;
   return self;
}


//////////////////////////////////
//
// getCorner4UTMNorthing
//
//////////////////////////////////
- (double) getCorner4UTMNorthing
{
    return corner4UTMNorthing;
}


/////////////////////////////////////////
//
// setCorner1DisplayX
//
/////////////////////////////////////////
- setCorner1DisplayX: (unsigned int) aDisplayX
{
     corner1DisplayX = aDisplayX;
     return self;
}


/////////////////////////////////////////
//
// setCorner1DisplayY
//
/////////////////////////////////////////
- setCorner1DisplayY: (unsigned int) aDisplayY
{
     corner1DisplayY = aDisplayY;
     return self;
}


/////////////////////////////////////////
//
// setCorner2DisplayX
//
/////////////////////////////////////////
- setCorner2DisplayX: (unsigned int) aDisplayX
{
     corner2DisplayX = aDisplayX;
     return self;
}


/////////////////////////////////////////
//
// setCorner2DisplayY
//
/////////////////////////////////////////
- setCorner2DisplayY: (unsigned int) aDisplayY
{
     corner2DisplayY = aDisplayY;
     return self;
}


/////////////////////////////////////////
//
// setCorner3DisplayX
//
/////////////////////////////////////////
- setCorner3DisplayX: (unsigned int) aDisplayX
{
     corner3DisplayX = aDisplayX;
     return self;
}


/////////////////////////////////////////
//
// setCorner3DisplayY
//
/////////////////////////////////////////
- setCorner3DisplayY: (unsigned int) aDisplayY
{
     corner3DisplayY = aDisplayY;
     return self;
}


/////////////////////////////////////////
//
// setCorner4DisplayX
//
/////////////////////////////////////////
- setCorner4DisplayX: (unsigned int) aDisplayX
{
     corner4DisplayX = aDisplayX;
     return self;
}


/////////////////////////////////////////
//
// setCorner4DisplayY
//
/////////////////////////////////////////
- setCorner4DisplayY: (unsigned int) aDisplayY
{
     corner4DisplayY = aDisplayY;
     return self;
}




////////////////////////////////////
//
// setMinDisplayX
//
////////////////////////////////////
- setMinDisplayX: (int) aMinDisplayX
{
   minDisplayX = aMinDisplayX;
   return self;
}



////////////////////////////////////
//
// setMaxDisplayX
//
////////////////////////////////////
- setMaxDisplayX: (int) aMaxDisplayX
{
   maxDisplayX = aMaxDisplayX;
   return self;
}



////////////////////////////////////
//
// setMinDisplayY
//
////////////////////////////////////
- setMinDisplayY: (int) aMinDisplayY
{
   minDisplayY = aMinDisplayY;
   return self;
}



////////////////////////////////////
//
// setMaxDisplayY
//
////////////////////////////////////
- setMaxDisplayY: (int) aMaxDisplayY
{
   maxDisplayY = aMaxDisplayY;
   return self;
}



//////////////////////////////////////////
//
// setMidPointNodesWith
//
//////////////////////////////////////////
- setMidPointNodesWith: (int) aMidPointNode1
         midPointNode2: (int) aMidPointNode2
         midPointNode3: (int) aMidPointNode3
         midPointNode4: (int) aMidPointNode4
{
    midPointNode1 = aMidPointNode1;
    midPointNode2 = aMidPointNode2;
    midPointNode3 = aMidPointNode3;
    midPointNode4 = aMidPointNode4;

    return self;
}


//////////////////////////
//
// getMidPointNode1
//
//////////////////////////
- (int) getMidPointNode1
{
    return midPointNode1;
}

//////////////////////////
//
// getMidPointNode2
//
//////////////////////////
- (int) getMidPointNode2
{
    return midPointNode2;
}

//////////////////////////
//
// getMidPointNode3
//
//////////////////////////
- (int) getMidPointNode3
{
    return midPointNode3;
}

//////////////////////////
//
// getMidPointNode4
//
//////////////////////////
- (int) getMidPointNode4
{
    return midPointNode4;
}


- setMidPoint1UTMEasting: (double) aCoordinate
{
    midPoint1UTMEasting = aCoordinate;
    return self;
}


- (double) getMidPoint1UTMEasting
{
    return midPoint1UTMEasting;
}

- setMidPoint1UTMNorthing: (double) aCoordinate
{
    midPoint1UTMNorthing = aCoordinate;
    return self;
}


- (double) getMidPoint1UTMNorthing
{
    return midPoint1UTMNorthing;
}

- setMidPoint2UTMEasting: (double) aCoordinate
{
    midPoint1UTMEasting = aCoordinate;
    return self;
}


- (double) getMidPoint2UTMEasting
{
    return midPoint2UTMEasting;
}

- setMidPoint2UTMNorthing: (double) aCoordinate
{
    midPoint2UTMNorthing = aCoordinate;
    return self;
}


- (double) getMidPoint2UTMNorthing
{
    return midPoint2UTMNorthing;
}


- setMidPoint3UTMEasting: (double) aCoordinate
{
    midPoint3UTMEasting = aCoordinate;
    return self;
}


- (double) getMidPoint3UTMEasting
{
    return midPoint3UTMEasting;
}

- setMidPoint3UTMNorthing: (double) aCoordinate
{
    midPoint3UTMNorthing = aCoordinate;
    return self;
}


- (double) getMidPoint3UTMNorthing
{
    return midPoint3UTMNorthing;
}

- setMidPoint4UTMEasting: (double) aCoordinate
{
    midPoint4UTMEasting = aCoordinate;
    return self;
}


- (double) getMidPoint4UTMEasting
{
    return midPoint4UTMEasting;
}

- setMidPoint4UTMNorthing: (double) aCoordinate
{
    midPoint4UTMNorthing = aCoordinate;
    return self;
}


- (double) getMidPoint4UTMNorthing
{
    return midPoint4UTMNorthing;
}




////////////////////////////////////////////////
//
// setRaster* 
//
///////////////////////////////////////////
- setUTMRasterResolution: (int) aResolution 
{
  utmRasterResolution = aResolution;
  return self;
}


- (int) getUTMRasterResolution 
{
  return utmRasterResolution;
}

- setUTMRasterResolutionX: (int) aResolutionX 
{
  utmRasterResolutionX = aResolutionX;
  return self;
}

- (int) getUTMRasterResolutionX 
{
  return utmRasterResolutionX;
}

- setUTMRasterResolutionY: (int) aResolutionY 
{
  utmRasterResolutionY = aResolutionY;
  return self;
}

- (int) getUTMRasterResolutionY 
{
  return utmRasterResolutionY;
}



////////////////////////////////////////////////
//
// setVelocityInterpolator
//
////////////////////////////////////////////////
-  setVelocityInterpolator: (id <InterpolationTable>) aVelocityInterpolator
{
    velocityInterpolator = aVelocityInterpolator;
    return self;
}


////////////////////////////////////////////////////
//
// getVelocityInterpolator
//
////////////////////////////////////////////////////
-  (id <InterpolationTable>) getVelocityInterpolator
{
   return velocityInterpolator;
}


////////////////////////////////////////////////
//
// setDepthInterpolator
//
////////////////////////////////////////////////
-  setDepthInterpolator: (id <InterpolationTable>) aDepthInterpolator
{
    depthInterpolator = aDepthInterpolator;
    return self;
}
/////////////////////////////////////////////////////
//
// getDepthInterpolator
//
/////////////////////////////////////////////////////
-  (id <InterpolationTable>) getDepthInterpolator
{
    return depthInterpolator;
}



/////////////////////////////////////////////////
//
// createUTMCellCoordStructures
//
// Got rid of the ZoneAllocMapper 7/17/08 sjk
//
//////////////////////////////////////////////////
- createUTMCellCoordStructures
{
    int i = 0;

    //fprintf(stdout, "UTMCell >>>> createUTMCCelloordStructures >>>> utmCellNumber = %d >>>> BEGIN\n", utmCellNumber);
    //fflush(0);
 
    utmPointArray = (UTMPoint **) [cellZone allocBlock: (numberOfNodes + 1) * sizeof(UTMPoint *)];

    displayPointArray = (DisplayPoint **) [cellZone allocBlock: (numberOfNodes + 1) * sizeof(DisplayPoint *)];

    cornerNodeArray = (int **) [cellZone allocBlock: (numberOfNodes + 1) * sizeof(int *)];

    if(cornerNode1 != 0)
    {
       UTMPoint* corner1Point = (UTMPoint *) [cellZone allocBlock: sizeof(UTMPoint)];

       DisplayPoint* display1Point = (DisplayPoint *) [cellZone allocBlock: sizeof(DisplayPoint)];

       cornerNodeArray[i] = (int *) [cellZone allocBlock: (numberOfNodes + 1) * sizeof(int)];

       corner1Point->x = corner1UTMEasting;
       corner1Point->y = corner1UTMNorthing;
       utmPointArray[i] = corner1Point;

       display1Point->x = corner1DisplayX;
       display1Point->y = corner1DisplayY;
       displayPointArray[i] = display1Point;
 
       *cornerNodeArray[i] = cornerNode1;

       i++;
    }

    if(cornerNode2 != 0)
    {
       UTMPoint* corner2Point = (UTMPoint *) [cellZone allocBlock: sizeof(UTMPoint)];;

       DisplayPoint* display2Point = (DisplayPoint *) [cellZone allocBlock: sizeof(DisplayPoint)];;

       cornerNodeArray[i] = (int *) [cellZone allocBlock: (numberOfNodes + 1) * sizeof(int)];

       corner2Point->x = corner2UTMEasting;
       corner2Point->y = corner2UTMNorthing;
       utmPointArray[i] = corner2Point;

       display2Point->x = corner2DisplayX;
       display2Point->y = corner2DisplayY;
       displayPointArray[i] = display2Point;

       *cornerNodeArray[i] = cornerNode2;

       i++;
    }

    if(cornerNode3 != 0)
    {
       UTMPoint* corner3Point = (UTMPoint *) [cellZone allocBlock: sizeof(UTMPoint)];

       DisplayPoint* display3Point = (DisplayPoint *) [cellZone allocBlock: sizeof(DisplayPoint)];;

       cornerNodeArray[i] = (int *) [cellZone allocBlock: (numberOfNodes + 1) * sizeof(int)];

       corner3Point->x = corner3UTMEasting;
       corner3Point->y = corner3UTMNorthing;
       utmPointArray[i] = corner3Point;

       display3Point->x = corner3DisplayX;
       display3Point->y = corner3DisplayY;
       displayPointArray[i] = display3Point;

       *cornerNodeArray[i] = cornerNode3;

       i++;
    }

    if(cornerNode4 != 0)
    {
       UTMPoint* corner4Point = (UTMPoint *) [cellZone allocBlock: sizeof(UTMPoint)];

       DisplayPoint* display4Point = (DisplayPoint *) [cellZone allocBlock: sizeof(DisplayPoint)];

       cornerNodeArray[i] = (int *) [cellZone allocBlock: (numberOfNodes + 1) * sizeof(int)];

       corner4Point->x = corner4UTMEasting;
       corner4Point->y = corner4UTMNorthing;
       utmPointArray[i] = corner4Point;

       display4Point->x = corner4DisplayX;
       display4Point->y = corner4DisplayY;
       displayPointArray[i] = display4Point;

       *cornerNodeArray[i] = cornerNode4;
    }

    //fprintf(stdout, "UTMCell >>>> createUTMCCelloordStructures >>>> utmCellNumber = %d >>>> END\n", utmCellNumber);
    //fflush(0);

    return self;
}


//////////////////////////////////////
//
// getUTMPointArray
//
//////////////////////////////////////
- (UTMPoint **) getUTMPointArray
{
    return utmPointArray;
}

    


/////////////////////////////////////
//
// createUTMCellPixels
//
////////////////////////////////////
- createUTMCellPixels
{
  int aDisplayX = 0;
  int aDisplayY = 0;
  int i;

  //fprintf(stdout, "UTMCell >>>> createUTMCellPixels >>>> BEGIN\n");
  //fflush(0);

  maxDisplayX = -1;
  maxDisplayY = -1;
  for(i = 0; i < numberOfNodes; i++)
  {
      maxDisplayX = (maxDisplayX > displayPointArray[i]->x) ? maxDisplayX : displayPointArray[i]->x;
      maxDisplayY = (maxDisplayY > displayPointArray[i]->y) ? maxDisplayY : displayPointArray[i]->y;
  }


  minDisplayX = maxDisplayX;
  minDisplayY = maxDisplayY;
  for(i = 0; i < numberOfNodes; i++)
  {
      minDisplayX = (minDisplayX < displayPointArray[i]->x) ? minDisplayX : displayPointArray[i]->x;
      minDisplayY = (minDisplayY < displayPointArray[i]->y) ? minDisplayY : displayPointArray[i]->y;
  }

  pixelCount = 0;
  for(aDisplayX = minDisplayX; aDisplayX <= maxDisplayX; aDisplayX++)
  {
      for(aDisplayY = minDisplayY; aDisplayY <= maxDisplayY; aDisplayY++)
      {
          if([self containsRasterX: aDisplayX andRasterY: aDisplayY])
          {
               pixelCount++;
          }
      }
  }

  if(pixelCount > 0)
  {
     i = 0;
     utmCellPixels = (PixelCoord **) [ZoneAllocMapper allocBlockIn: cellZone
                                                           ofSize: pixelCount * sizeof(PixelCoord *)];

     for(aDisplayX = minDisplayX; aDisplayX <= maxDisplayX; aDisplayX++)
     {
         for(aDisplayY = minDisplayY; aDisplayY <= maxDisplayY; aDisplayY++)
         {
             if([self containsRasterX: aDisplayX andRasterY: aDisplayY])
             {
                  if(i < pixelCount)
                  {
                      utmCellPixels[i] = (PixelCoord *) [ZoneAllocMapper allocBlockIn: cellZone
                                                        ofSize: sizeof(PixelCoord)];
                  
                      utmCellPixels[i]->pixelX = aDisplayX;
                      utmCellPixels[i]->pixelY = aDisplayY;
                      i++;
                   
                  }
             }
         }
     }
   }
  
  //fprintf(stdout, "UTMCell >>>> createUTMCellPixels >>>> END\n");
  //fflush(0);
  
  return self;
} 


/////////////////////////////////////////////////////////////
//
// calcUTMCellCentroid
//
// This method also calculates the utmCellArea
// Area Reference: O'Rourke, J (1998),
//                 Computational Geometry in C, 2nd Edition
//                 Cambridge University Press, Cambridge
//                 p. 21
//
// Centroid Reference: Harris, J.W., Stocker, H., (1998)
//                     Handbook of Mathematics and Computational Science
//                     Springer-Verlag, New York
//                     p. 378
/////////////////////////////////////////////////////////////
- calcUTMCellCentroid
{
   int i;
   int j;

   //fprintf(stdout, "UTMCell >>>> calcUTMCellCentroid >>>> BEGIN\n");
   //fflush(0);

   utmCellArea = 0.0;
   utmCenterX = 0.0;
   utmCenterY = 0.0;

   for(i = 0; i < numberOfNodes; i++) 
   {
      j = (i + 1) % numberOfNodes;

      utmCellArea += utmPointArray[i]->x * utmPointArray[j]->y;
      utmCellArea -= utmPointArray[i]->y * utmPointArray[j]->x;
   }

   utmCellArea /= 2;

   if(utmCellArea <= 0.0)
   {
      fprintf(stderr, "ERROR: UTMCell >>>> calcUTMCellCentroid >>>> utmCellArea <= 0\n");
      fflush(0);
      exit(1);
   }

   for(i = 0; i < numberOfNodes; i++) 
   {
      j = (i + 1) % numberOfNodes;

      utmCenterX  += ((utmPointArray[i]->x + utmPointArray[j]->x) * 
                       (  utmPointArray[i]->x * utmPointArray[j]->y
                        - utmPointArray[j]->x * utmPointArray[i]->y));

      utmCenterY  += ((utmPointArray[i]->y + utmPointArray[j]->y) * 
                       (  utmPointArray[i]->x * utmPointArray[j]->y
                        - utmPointArray[j]->x * utmPointArray[i]->y));
   }

   utmCenterX = 0.0;
   utmCenterY = 0.0;

   for(i = 0; i < numberOfNodes; i++) 
   {
      utmCenterX  += utmPointArray[i]->x;
      utmCenterY  += utmPointArray[i]->y;
   }

   utmCenterX = utmCenterX/numberOfNodes;
   utmCenterY = utmCenterY/numberOfNodes;

   displayCenterX = (unsigned int) (utmCenterX - minUTMEasting) + 0.5;
   displayCenterX = displayCenterX/utmRasterResolutionX + 0.5;
   displayCenterY = (unsigned int) (maxUTMNorthing - utmCenterY) + 0.5;
   displayCenterY = displayCenterY/utmRasterResolutionY + 0.5;

   //fprintf(stdout, "UTMCell >>>> calcUTMCellCentroid >>>> utmCellNumber = %d >>>> utmCellArea = %f\n", utmCellNumber, utmCellArea);
   //fprintf(stdout, "UTMCell >>>> calcUTMCellCentroid >>>> utmCellNumber = %d >>>> utmCenterX = %f\n", utmCellNumber, utmCenterX);
   //fprintf(stdout, "UTMCell >>>> calcUTMCellCentroid >>>> utmCellNumber = %d >>>> utmCenterY = %f\n", utmCellNumber, utmCenterY);
   //fflush(0);
   //fprintf(stdout, "UTMCell >>>> calcUTMCellCentroid >>>> END\n");
   //fflush(0);

   return self;
}


////////////////////////////
//
// getUTMCenterX
//
////////////////////////////
- (double) getUTMCenterX
{
    return utmCenterX;
}



///////////////////////////////
//
// getUTMCenterY
//
///////////////////////////////
- (double) getUTMCenterY
{
    return utmCenterY;
}


/////////////////////////////
//
// getUTMCellArea
//
////////////////////////////
- (double) getUTMCellArea
{
    return utmCellArea;
}


//////////////////////////////////
//
// createUTMAdjacentCellsFrom
//
//////////////////////////////////
- createUTMAdjacentCellsFrom: (id <ListIndex>) habSpaceUTMCellListNdx
{
   id <ListIndex> ndx = habSpaceUTMCellListNdx;
   UTMCell* otherUTMCell = nil;

   int i;
   int j;

   //fprintf(stdout, "UTMCell >>>> createUTMAdjacentCells >>>> BEGIN\n");
   //fflush(0);

   listOfAdjacentCells = [List create: cellZone];

   [ndx setLoc: Start];

   while(([ndx getLoc] != End) && ((otherUTMCell = [ndx next]) != nil))
   {
       int otherCellNumNodes = [otherUTMCell getNumberOfNodes]; 
       int** otherCellsCornerNodes = [otherUTMCell getCornerNodeArray]; 

       if(otherUTMCell == self)
       {
          continue;
       }
 
       for(i = 0; i < numberOfNodes; i++)
       {
           for(j = 0; j < otherCellNumNodes; j++)
           {
                if(*cornerNodeArray[i] == *otherCellsCornerNodes[j])
                {
                     if([listOfAdjacentCells contains: otherUTMCell])
                     {
                         continue;
                     }

                     [listOfAdjacentCells addLast: otherUTMCell];
                }
           }
       }
   }

   //
   // Do not drop ndx, it belongs to HabitatSpace!!
   //

   //fprintf(stdout, "UTMCell >>>> createUTMAdjacentCells >>>> END\n");
   //fflush(0);

   return self;

}


/////////////////////////////////////
//
// getListOfAdjacentCells
//
////////////////////////////////////
- (id <List>) getListOfAdjacentCells
{
    return listOfAdjacentCells;
}


///////////////////////////////
//
// updateUTMCellDepth
//
///////////////////////////////
- updateUTMCellDepthWith: (double) aFlow
{
   utmCellDepth = [depthInterpolator getValueFor: aFlow];

   if(utmCellDepth < 0.0)
   {
       utmCellDepth = 0.0;
   }

   return self;
}


///////////////////////////////
//
// getUTMCellDepth
//
//////////////////////////////
- (double) getUTMCellDepth
{
    return utmCellDepth;
}


//////////////////////////////
//
// updateUTMCellVelocity
//
//////////////////////////////
- updateUTMCellVelocityWith: (double) aFlow
{
   utmCellVelocity = [velocityInterpolator getValueFor: aFlow];

   if(utmCellVelocity < 0.0)
   {
       utmCellVelocity = 0.0;
   }

   return self;
}


////////////////////////////////////
//
// getUTMCellVelocity
//
////////////////////////////////////
- (double) getUTMCellVelocity
{
    return utmCellVelocity;
}


//////////////////////////////////////////////////////////////////////////////
//
// containsRasterX
//
// Point in Polygon Reference: O'Rourke, J (1998),
//                             Computational Geometry in C, 2nd Edition
//                             Cambridge University Press, Cambridge
//                             pp 239-245
//
// Note: A point must be strictly interior for a 'YES' return value.
//       Points on the boundary are not handled consistently.
//
//////////////////////////////////////////////////////////////////////////////
- (BOOL) containsRasterX: (int) aRasterX andRasterY: (int) aRasterY
{
  int i;
  BOOL interiorPoint = NO; 
  double utmX;  
  double utmY;  

  int counter = 0;
  double xIntersect;

  //
  // Pointers to the utm coordinate structures
  //
  UTMPoint* p1 = NULL;
  UTMPoint* p2 = NULL;
 
  utmX = (double) (aRasterX * utmRasterResolutionX) + minUTMEasting;
  utmY = maxUTMNorthing - (double) (aRasterY * utmRasterResolutionY);

  //fprintf(stdout, "UTMCell >>>> containsProbedX: anProbedY: >>>> BEGIN\n");
  //fflush(0);

  p1 = utmPointArray[0]; 
  for(i = 1; i <= numberOfNodes; i++) 
  {
    double minP1P2Y;
    double maxP1P2Y;
    double maxP1P2X;

    p2 = utmPointArray[i % numberOfNodes];

    maxP1P2X = (p1->x > p2->x) ? p1->x : p2->x;
    minP1P2Y = (p1->y < p2->y) ? p1->y : p2->y;
    maxP1P2Y = (p1->y > p2->y) ? p1->y : p2->y;

    if(utmY > minP1P2Y)
    {
      if(utmY <= maxP1P2Y)
      {
        if(utmX <= maxP1P2X)
        {
          if(p1->y != p2->y) 
          {
            xIntersect = (utmY - p1->y) * (p2->x - p1->x)/(p2->y - p1->y) + p1->x;
            if (p1->x == p2->x || utmX <= xIntersect)
            {
              counter++;
            }
          }
        }
      }
    }

    p1 = p2;

  } //for 

  if (counter % 2 == 0)
  {
     interiorPoint = NO;
  }
  else
  {
     interiorPoint = YES;
  
  }
      
  //fprintf(stdout, "UTMCell >>>> containsProbedX: anProbedY: >>>> END\n");
  //fflush(0);

  return interiorPoint;
}



////////////////////////////////////////////////
//
// setRasterColorVariable
//
////////////////////////////////////////////////
- setUTMRasterColorVariable: (char *) aColorVariable 
{
   rasterColorVariable = (char *) [ZoneAllocMapper allocBlockIn: cellZone
                                                         ofSize: 25 * sizeof(char)];
   strncpy(rasterColorVariable, aColorVariable, 25);

   return self;
}



//#define COLOR_MODIFIER 1.8679
//#define COLOR_MODIFIER 1.7
#define COLOR_MODIFIER 8.065  // This scales colors 0-62 to values of 0-500 
/////////////////////////////////////////////////////////////////////
//
// drawSelfOn
//
/////////////////////////////////////////////////////////////////////
- drawSelfOn: (id <Raster>) aRaster 
   withPhase: (int) aPhase
{
  double colorVariable = 0.0;
  int i;

  //fprintf(stdout, "UTMCell >>>> drawSelfOn >>>> BEGIN\n");
  //fflush(0);

  interiorColor = UTMINTERIORCOLOR; 
  boundaryColor = UTMBOUNDARYCOLOR;


  // first calculate color to use
  // [0,100] use continous scale
  // [101,1000] use bin values

  if(rasterColorVariable == NULL)
  {
      fprintf(stderr, "ERROR: UTMCell >>>> drawSelfOn >>>> rasterColorVariable has not been set\n");
      fflush(0);
      exit(1);
  }


  if(strcmp("depth",rasterColorVariable) == 0) 
  {
       colorVariable = utmCellDepth; 
  }
  else if(strcmp("velocity",rasterColorVariable) == 0) 
  {
      colorVariable = utmCellVelocity; 
  }
  else 
  {
        fprintf(stderr, "ERROR: Unknown rasterColorVariable value = %s\n",rasterColorVariable);
        fflush(0);
        exit(1);
  }

  if(tagCell)
  {
     interiorColor = TAG_CELL_COLOR;
  }
  else
  {
      if ((0.0 <= colorVariable) && (colorVariable <= 500.0))
      {
        interiorColor = (int)(colorVariable/COLOR_MODIFIER + 0.5);
      }
      else if (500.0 < colorVariable)
      {
        interiorColor = 63L;
      }
      else
      {
        interiorColor = 0L;
      }

      // put a lower bound on the color
      if (interiorColor <= 0)
      {
          interiorColor = 1L;
      }
  }

  if(aPhase == DAY) interiorColor = 63L - interiorColor;

  if(1)
  {
     for(i = 0;i < pixelCount; i++)
     {
         [aRaster drawPointX: utmCellPixels[i]->pixelX 
                           Y: utmCellPixels[i]->pixelY 
                       Color: interiorColor];
     }
  }
 
  for(i = 1; i <= numberOfNodes; i++) 
  { 
      [aRaster lineX0: displayPointArray[i - 1]->x
                   Y0: displayPointArray[i - 1]->y
                   X1: displayPointArray[i % numberOfNodes]->x
                   Y1: displayPointArray[i % numberOfNodes]->y
                Width: 1
                   Color: boundaryColor];
  }
  
  //fprintf(stdout, "UTMCell >>>> drawSelfOn >>>> END\n");
  //fflush(0);

  return self;
}



///////////////////////////////////
//
// tagUTMCell
//
///////////////////////////////////
- tagUTMCell
{
    tagCell = YES;
    return self;
}

///////////////////////////////////
//
// unTagUTMCell
//
///////////////////////////////////
- unTagUTMCell
{
    tagCell = NO;
    return self;
}


////////////////////////////////////////
//
// tagAdjacentCells
//
///////////////////////////////////////
- tagAdjacentCells
{
    [listOfAdjacentCells forEach: M(tagUTMCell)];
    return self;
}


/////////////////////////////////////////
//
// drop
//
////////////////////////////////////////
- (void) drop
{
    int i = 0;

    //fprintf(stdout, "UTMCell >>>> drop >>>> BEGIN\n");
    //fflush(0);

    //
    // First drop all of the arrays
    //
    if(cornerNode1 != 0)
    {
         [cellZone freeBlock: utmPointArray[i] blockSize: sizeof(UTMPoint)];
         [cellZone freeBlock: displayPointArray[i] blockSize: sizeof(DisplayPoint)];
         [cellZone freeBlock: cornerNodeArray[i] blockSize: sizeof(DisplayPoint)];

         i++;
    }
    if(cornerNode2 != 0)
    {
         [cellZone freeBlock: utmPointArray[i] blockSize: sizeof(UTMPoint)];
         [cellZone freeBlock: displayPointArray[i] blockSize: sizeof(DisplayPoint)];
         [cellZone freeBlock: cornerNodeArray[i] blockSize: sizeof(DisplayPoint)];

         i++;
    }
    if(cornerNode3 != 0)
    {
         [cellZone freeBlock: utmPointArray[i] blockSize: sizeof(UTMPoint)];
         [cellZone freeBlock: displayPointArray[i] blockSize: sizeof(DisplayPoint)];
         [cellZone freeBlock: cornerNodeArray[i] blockSize: sizeof(DisplayPoint)];

         i++;
    }
    if(cornerNode4 != 0)
    {
         [cellZone freeBlock: utmPointArray[i] blockSize: sizeof(UTMPoint)];
         [cellZone freeBlock: displayPointArray[i] blockSize: sizeof(DisplayPoint)];
         [cellZone freeBlock: cornerNodeArray[i] blockSize: sizeof(DisplayPoint)];
    }
        
   [velocityInterpolator drop];
   [depthInterpolator drop];


   [cellZone drop];

    //fprintf(stdout, "UTMCell >>>> drop >>>> END\n");
    //fflush(0);

}
@end
